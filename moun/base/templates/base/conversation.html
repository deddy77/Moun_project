{% extends 'main.html' %}

{% block content %}
<style>
    .chat-container {
        max-width: 900px;
        margin: 2rem auto;
        height: calc(100vh - 200px);
        display: flex;
        flex-direction: column;
        background: white;
        border-radius: 16px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        overflow: hidden;
    }

    .chat-header {
        padding: 1.5rem 1.25rem;
        border-bottom: 2px solid var(--color-main-light);
        display: flex;
        align-items: center;
        gap: 1rem;
        background: linear-gradient(135deg, #ffffff, var(--color-main-light));
    }

    .chat-header img {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid var(--color-main);
    }

    .chat-header-info h2 {
        margin: 0;
        font-size: 1.3rem;
        font-weight: 600;
        color: var(--color-dark);
    }

    .back-link {
        color: var(--color-main);
        text-decoration: none;
        font-size: 0.95rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.25rem;
        transition: color 0.2s;
    }

    .back-link:hover {
        color: var(--color-dark-medium);
    }

    .messages-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 1.5rem 1rem;
        background: #1C1C1C;
        display: flex;
        flex-direction: column;
    }

    .date-separator {
        text-align: center;
        margin: 1.5rem 0 1rem 0;
        position: relative;
    }

    .date-separator span {
        background: #2E2E2E;
        color: #00FFFF;
        padding: 0.4rem 1rem;
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: inline-block;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .message {
        display: flex;
        margin-bottom: 0.75rem;
        gap: 0.5rem;
        animation: fadeIn 0.3s ease-in;
        align-items: flex-end;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .message.sent {
        flex-direction: row-reverse;
        justify-content: flex-start;
    }

    .message.received {
        justify-content: flex-start;
    }

    .message-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
        border: 2px solid var(--color-light);
        align-self: flex-end;
    }

    .message-content {
        max-width: 75%;
        display: flex;
        flex-direction: column;
        position: relative;
    }

    .message.sent .message-content {
        align-items: flex-end;
    }

    .message.received .message-content {
        align-items: flex-start;
    }

    .sender-name {
        font-size: 0.75rem;
        font-weight: 600;
        color: #00FFFF;
        margin-bottom: 0.25rem;
        padding: 0 0.5rem;
    }

    .message-bubble {
        padding: 0.5rem 0.75rem;
        border-radius: 16px;
        word-wrap: break-word;
        white-space: pre-wrap;
        line-height: 1.4;
        font-size: 0.9rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: inline-block;
        width: fit-content;
        position: relative;
        padding-bottom: 1.3rem;
    }

    .message.received .message-bubble {
        background: #2E2E2E;
        color: #E0E0E0;
        border-top-left-radius: 4px;
        border: 1px solid #3C3C3C;
    }

    .message.sent .message-bubble {
        background: linear-gradient(135deg, #008080, #3A7CA5);
        color: #F5F5F5;
        border-top-right-radius: 4px;
    }

    .message-time {
        position: absolute;
        bottom: 0.3rem;
        right: 0.6rem;
        font-size: 0.65rem;
        font-weight: 400;
        opacity: 0.7;
    }

    .message.received .message-time {
        color: #A0A0A0;
    }

    .message.sent .message-time {
        color: rgba(245, 245, 245, 0.7);
    }

    .message-form {
        padding: 0.5rem 1rem 0.75rem 1rem;
        border-top: 1px solid #2E2E2E;
        background: #1C1C1C;
    }

    .message-input-container {
        display: flex;
        align-items: flex-end;
        gap: 0.5rem;
    }

    .input-field-wrapper {
        flex: 1;
        display: flex;
        align-items: center;
        background: #2E2E2E;
        border-radius: 24px;
        padding: 0.4rem 0.7rem 0.4rem 0.4rem;
        border: 1px solid #3C3C3C;
        transition: border-color 0.2s;
        gap: 0.4rem;
    }

    .input-field-wrapper:focus-within {
        border-color: #00FFFF;
    }

    .message-input-wrapper {
        flex: 1;
        display: flex;
        align-items: center;
    }

    .media-buttons {
        display: flex;
        gap: 0.25rem;
        align-items: center;
    }

    .media-btn {
        width: 42px;
        height: 42px;
        min-width: 42px;
        border-radius: 50%;
        border: none;
        background: transparent;
        color: #8696A0;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        padding: 0;
    }

    .media-btn:hover {
        background: rgba(134, 150, 160, 0.1);
    }

    .media-btn:active {
        transform: scale(0.95);
    }

    .media-btn.recording {
        color: #FF4444;
        animation: pulse 1.5s infinite;
    }

    .media-btn svg {
        width: 24px;
        height: 24px;
        stroke-width: 2;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    .message-input {
        flex: 1;
        padding: 0.6rem 0.5rem;
        border: none;
        border-radius: 20px;
        font-size: 15px;
        resize: none;
        max-height: 100px;
        font-family: inherit;
        line-height: 1.4;
        transition: all 0.2s ease;
        background: transparent;
        color: #E0E0E0;
        outline: none;
    }

    .message-input::placeholder {
        color: #8696A0;
    }

    .send-button {
        width: 48px;
        height: 48px;
        min-width: 48px;
        background: linear-gradient(135deg, #008080, #3A7CA5);
        color: #FFFFFF;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 6px rgba(0, 128, 128, 0.25);
        display: none;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        padding: 0;
    }

    .send-button.visible {
        display: flex;
    }

    .send-button svg {
        width: 22px;
        height: 22px;
        stroke-width: 2.5;
    }

    .send-button:hover {
        transform: scale(1.05);
        box-shadow: 0 3px 10px rgba(0, 128, 128, 0.35);
    }

    .send-button:active {
        transform: scale(0.95);
    }

    .send-button:disabled {
        background: #4A4A4A;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
        opacity: 0.6;
    }

    /* Sticker picker */
    .sticker-picker {
        position: absolute;
        bottom: 70px;
        left: 1rem;
        right: 1rem;
        max-width: 400px;
        background: #2E2E2E;
        border: 2px solid #3C3C3C;
        border-radius: 16px;
        padding: 1rem;
        display: none;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
        z-index: 100;
    }

    .sticker-picker.active {
        display: block;
        animation: slideUp 0.2s ease;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .sticker-picker-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #3C3C3C;
    }

    .sticker-picker-title {
        color: #00FFFF;
        font-weight: 600;
        font-size: 0.95rem;
    }

    .sticker-picker-close {
        background: none;
        border: none;
        color: #808080;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s;
    }

    .sticker-picker-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #E0E0E0;
    }

    .sticker-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
        gap: 0.5rem;
        max-height: 250px;
        overflow-y: auto;
    }

    .sticker-item {
        font-size: 2.5rem;
        text-align: center;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        transition: all 0.2s;
        background: transparent;
        border: none;
    }

    .sticker-item:hover {
        background: rgba(0, 255, 255, 0.1);
        transform: scale(1.2);
    }

    .sticker-item:active {
        transform: scale(0.95);
    }

    /* Voice Recording UI */
    .voice-recording-overlay {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(to top, #1C1C1C 0%, #1C1C1C 90%, transparent 100%);
        padding: 2rem 1rem 1rem;
        display: none;
        z-index: 200;
        transition: all 0.3s ease;
    }

    .voice-recording-overlay.active {
        display: block;
        animation: slideUpOverlay 0.3s ease;
    }

    @keyframes slideUpOverlay {
        from {
            opacity: 0;
            transform: translateY(100%);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .voice-recording-content {
        max-width: 600px;
        margin: 0 auto;
        text-align: center;
    }

    .voice-recording-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
    }

    .recording-timer {
        font-size: 1.5rem;
        font-weight: 600;
        color: #00FFFF;
        font-variant-numeric: tabular-nums;
    }

    .recording-timer.warning {
        color: #FF4444;
        animation: pulse 1s infinite;
    }

    .lock-indicator {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        color: #8696A0;
        font-size: 0.85rem;
    }

    .lock-icon {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: rgba(0, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }

    .lock-icon svg {
        width: 20px;
        height: 20px;
        stroke: #00FFFF;
        stroke-width: 2;
    }

    .lock-icon.locked {
        background: rgba(0, 255, 255, 0.3);
    }

    .waveform-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 3px;
        height: 60px;
        margin: 1.5rem 0;
    }

    .waveform-bar {
        width: 4px;
        background: linear-gradient(to top, #008080, #00FFFF);
        border-radius: 2px;
        transition: height 0.1s ease;
        animation: waveAnimation 1s ease-in-out infinite;
    }

    @keyframes waveAnimation {
        0%, 100% { height: 10px; }
        50% { height: 40px; }
    }

    .recording-controls {
        display: flex;
        justify-content: center;
        gap: 2rem;
        margin-top: 2rem;
    }

    .voice-control-btn {
        width: 64px;
        height: 64px;
        border-radius: 50%;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .voice-control-btn svg {
        width: 28px;
        height: 28px;
        stroke-width: 2.5;
    }

    .cancel-btn {
        background: #FF4444;
        color: #FFFFFF;
    }

    .cancel-btn:hover {
        background: #FF3333;
        transform: scale(1.05);
    }

    .send-voice-btn {
        background: linear-gradient(135deg, #008080, #3A7CA5);
        color: #FFFFFF;
    }

    .send-voice-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 16px rgba(0, 128, 128, 0.4);
    }

    .pause-btn {
        background: #2E2E2E;
        color: #00FFFF;
        border: 2px solid #00FFFF;
    }

    .pause-btn:hover {
        background: rgba(0, 255, 255, 0.1);
    }

    .slide-instructions {
        margin-top: 1.5rem;
        color: #8696A0;
        font-size: 0.9rem;
        display: flex;
        justify-content: center;
        gap: 2rem;
    }

    .slide-instruction {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    /* Voice Message Playback */
    .voice-message {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem;
        min-width: 200px;
    }

    .voice-play-btn {
        width: 36px;
        height: 36px;
        min-width: 36px;
        border-radius: 50%;
        background: rgba(0, 255, 255, 0.2);
        border: 2px solid #00FFFF;
        color: #00FFFF;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
    }

    .voice-play-btn:hover {
        background: rgba(0, 255, 255, 0.3);
        transform: scale(1.05);
    }

    .voice-play-btn svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
    }

    .voice-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
    }

    .voice-progress-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .voice-waveform {
        flex: 1;
        height: 32px;
        display: flex;
        align-items: center;
        gap: 2px;
        cursor: pointer;
    }

    .voice-waveform-bar {
        flex: 1;
        height: 100%;
        background: rgba(0, 255, 255, 0.3);
        border-radius: 2px;
        transition: all 0.2s;
        position: relative;
    }

    .voice-waveform-bar.played {
        background: #00FFFF;
    }

    .voice-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.7rem;
        color: #8696A0;
    }

    .voice-duration {
        font-variant-numeric: tabular-nums;
    }

    .voice-speed {
        background: rgba(0, 255, 255, 0.1);
        padding: 0.15rem 0.4rem;
        border-radius: 8px;
        cursor: pointer;
        user-select: none;
        transition: all 0.2s;
    }

    .voice-speed:hover {
        background: rgba(0, 255, 255, 0.2);
    }

    .empty-messages {
        text-align: center;
        padding: 3rem 2rem;
        color: #808080;
    }

    .empty-messages p {
        font-size: 1.1rem;
        margin: 0;
    }

    /* Media message styles */
    .message-media {
        max-width: 280px;
        margin-bottom: 0.3rem;
    }

    .message-media img {
        width: 100%;
        border-radius: 12px;
        cursor: pointer;
    }

    .message-media video {
        width: 100%;
        border-radius: 12px;
    }

    .message-media audio {
        width: 100%;
    }

    .voice-message {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem;
    }

    .voice-play-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(0, 255, 255, 0.2);
        border: 2px solid #00FFFF;
        color: #00FFFF;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 0.9rem;
    }

    .voice-waveform {
        flex: 1;
        height: 32px;
        background: repeating-linear-gradient(
            90deg,
            #00FFFF 0px,
            #00FFFF 2px,
            transparent 2px,
            transparent 6px
        );
        border-radius: 16px;
        opacity: 0.3;
    }

    .voice-duration {
        font-size: 0.75rem;
        opacity: 0.7;
    }

    /* Reply feature styles */
    .reply-preview {
        display: none;
        background: #2E2E2E;
        padding: 0.6rem 0.9rem;
        border-left: 3px solid #00FFFF;
        margin-bottom: 0.5rem;
        border-radius: 12px;
        position: relative;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .reply-preview.active {
        display: block;
        animation: slideDown 0.2s ease;
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .reply-preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.3rem;
    }

    .reply-preview-title {
        font-size: 0.75rem;
        font-weight: 600;
        color: #00FFFF;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .reply-preview-close {
        background: rgba(0, 255, 255, 0.15);
        border: none;
        font-size: 1rem;
        color: #00FFFF;
        cursor: pointer;
        padding: 0;
        width: 22px;
        height: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
    }

    .reply-preview-close:hover {
        background: rgba(0, 255, 255, 0.25);
        transform: rotate(90deg);
    }

    .reply-preview-body {
        font-size: 0.8rem;
        color: #B0B0B0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-style: italic;
    }

    .message-with-reply .replied-message {
        background: rgba(0, 0, 0, 0.3);
        padding: 0.4rem 0.6rem;
        border-left: 3px solid #00FFFF;
        border-radius: 6px;
        margin-bottom: 0.5rem;
        font-size: 0.8rem;
        color: #B0B0B0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-style: italic;
    }

    .message.sent .message-with-reply .replied-message {
        background: rgba(255, 255, 255, 0.15);
        color: rgba(245, 245, 245, 0.8);
        border-left-color: rgba(245, 245, 245, 0.6);
    }

    .replied-message strong {
        color: #00FFFF;
        font-size: 0.75rem;
        display: block;
        margin-bottom: 0.15rem;
    }

    .message-bubble-wrapper {
        position: relative;
        transition: transform 0.2s ease;
    }

    .reply-indicator {
        position: absolute;
        right: -50px;
        top: 50%;
        transform: translateY(-50%);
        opacity: 0;
        transition: opacity 0.2s ease;
        font-size: 1.5rem;
    }

    @media (max-width: 768px) {
        .chat-container {
            margin: 1rem;
            height: calc(100vh - 150px);
            border-radius: 12px;
        }

        .messages-container {
            padding: 1.5rem 1rem;
        }

        .message-content {
            max-width: 80%;
        }

        .message-bubble {
            padding: 0.85rem 1rem;
            font-size: 0.95rem;
        }
    }
</style>

<div class="chat-container">
    <div class="chat-header">
        <a href="{% url 'inbox' %}" class="back-link">‚Üê Back</a>
        {% if other_user.avatar %}
            <img src="{{ other_user.avatar.url }}" alt="{{ other_user.username }}">
        {% else %}
            <div style="width: 48px; height: 48px; background: linear-gradient(135deg, var(--color-main-light), var(--color-main)); border-radius: 50%; border: 3px solid var(--color-main);"></div>
        {% endif %}
        <div class="chat-header-info">
            <h2>{{ other_user.username }}</h2>
        </div>
    </div>

    <div class="messages-container" id="messages">
        {% for message in messages %}
            {% ifchanged message.created|date:"Y-m-d" %}
                <div class="date-separator">
                    <span>
                        {% now "Y-m-d" as today %}
                        {% now "Y-m-d"|date:"U" as today_timestamp %}
                        {% with message.created|date:"Y-m-d" as msg_date %}
                            {% with message.created|date:"U" as msg_timestamp %}
                                {% if msg_date == today %}
                                    Today
                                {% else %}
                                    {% with today_timestamp|add:"-86400" as yesterday_timestamp %}
                                        {% if msg_timestamp >= yesterday_timestamp|stringformat:"s" %}
                                            Yesterday
                                        {% else %}
                                            {{ message.created|date:"l, F j, Y" }}
                                        {% endif %}
                                    {% endwith %}
                                {% endif %}
                            {% endwith %}
                        {% endwith %}
                    </span>
                </div>
            {% endifchanged %}
            <div class="message {% if message.sender == request.user %}sent{% else %}received{% endif %}" 
                 data-message-id="{{ message.id }}"
                 data-message-body="{{ message.body }}"
                 data-sender="{{ message.sender.username }}">
                
                <div class="message-content">
                    <div class="message-bubble-wrapper">
                        <div class="message-bubble {% if message.reply_to %}message-with-reply{% endif %}">
                            {% if message.reply_to %}
                                <div class="replied-message">
                                    <strong>{{ message.reply_to.sender.username }}:</strong> 
                                    {% if message.reply_to.file_type == 'image' %}üì∑ Photo
                                    {% elif message.reply_to.file_type == 'video' %}üé• Video
                                    {% elif message.reply_to.file_type == 'voice' %}üé§ Voice message
                                    {% else %}{{ message.reply_to.body|truncatewords:10 }}
                                    {% endif %}
                                </div>
                            {% endif %}
                            
                            {% if message.file_type == 'image' %}
                                <div class="message-media">
                                    <img src="{{ message.file.url }}" alt="Image" loading="lazy">
                                </div>
                            {% elif message.file_type == 'video' %}
                                <div class="message-media">
                                    <video controls>
                                        <source src="{{ message.file.url }}" type="video/mp4">
                                    </video>
                                </div>
                            {% elif message.file_type == 'voice' %}
                                <div class="voice-message" data-message-id="{{ message.id }}">
                                    <button class="voice-play-btn" onclick="playVoice(this, '{{ message.file.url }}', {{ message.id }})">
                                        <svg viewBox="0 0 24 24" fill="currentColor">
                                            <polygon points="5 3 19 12 5 21 5 3"/>
                                        </svg>
                                    </button>
                                    <div class="voice-content">
                                        <div class="voice-progress-container">
                                            <div class="voice-waveform">
                                                {% for i in "12345678910111213141516171819202122232425" %}
                                                    <div class="voice-waveform-bar"></div>
                                                {% endfor %}
                                            </div>
                                        </div>
                                        <div class="voice-info">
                                            <span class="voice-duration">{{ message.voice_duration|default:"0" }}s</span>
                                            <span class="voice-speed" onclick="cyclePlaybackSpeed({{ message.id }}, this)">1x</span>
                                        </div>
                                    </div>
                                    <audio style="display:none;" src="{{ message.file.url }}"></audio>
                                </div>
                            {% endif %}
                            
                            {% if message.body %}
                                {{ message.body }}
                            {% endif %}
                            <span class="message-time">{{ message.created|date:"g:i A" }}</span>
                        </div>
                        <span class="reply-indicator">‚Ü©Ô∏è</span>
                    </div>
                </div>
            </div>
        {% empty %}
            <div class="empty-messages">
                <p>üí¨ No messages yet. Start the conversation!</p>
            </div>
        {% endfor %}
    </div>

    <form method="POST" class="message-form" id="messageForm" enctype="multipart/form-data">
        {% csrf_token %}
        <input type="hidden" name="reply_to_id" id="replyToId" value="">
        <input type="hidden" name="voice_duration" id="voiceDuration" value="">
        <input type="file" id="imageInput" name="file" accept="image/*" style="display:none;">
        <input type="file" id="videoInput" name="file" accept="video/*" style="display:none;">
        <input type="file" id="fileInput" name="file" style="display:none;">
        
        <!-- Reply Preview -->
        <div class="reply-preview" id="replyPreview">
            <div class="reply-preview-header">
                <span class="reply-preview-title">Replying to <span id="replyToUser"></span></span>
                <button type="button" class="reply-preview-close" onclick="cancelReply()">√ó</button>
            </div>
            <div class="reply-preview-body" id="replyPreviewBody"></div>
        </div>
        
        <!-- Sticker Picker -->
        <div class="sticker-picker" id="stickerPicker">
            <div class="sticker-picker-header">
                <span class="sticker-picker-title">Choose a sticker</span>
                <button type="button" class="sticker-picker-close" onclick="closeStickerPicker()">√ó</button>
            </div>
            <div class="sticker-grid" id="stickerGrid"></div>
        </div>
        
        <div class="message-input-container">
            <div class="input-field-wrapper">
                <div class="media-buttons">
                    <button type="button" class="media-btn" onclick="toggleStickerPicker()" title="Emoji">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                            <line x1="9" y1="9" x2="9.01" y2="9"/>
                            <line x1="15" y1="9" x2="15.01" y2="9"/>
                        </svg>
                    </button>
                </div>
                <div class="message-input-wrapper">
                    <textarea 
                        name="body" 
                        class="message-input" 
                        placeholder="Message" 
                        rows="1"
                        id="messageInput"
                        oninput="toggleSendButton()"
                    ></textarea>
                </div>
                <div class="media-buttons">
                    <button type="button" class="media-btn" id="attachBtn" onclick="document.getElementById('imageInput').click()" title="Attach">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48"/>
                        </svg>
                    </button>
                    <button type="button" class="media-btn" id="cameraBtn" onclick="document.getElementById('imageInput').click()" title="Camera">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/>
                            <circle cx="12" cy="13" r="4"/>
                        </svg>
                    </button>
                    <button type="button" class="media-btn" id="voiceBtn" onmousedown="startVoiceRecording(event)" ontouchstart="startVoiceRecording(event)" title="Voice message">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/>
                            <path d="M19 10v2a7 7 0 01-14 0v-2"/>
                            <line x1="12" y1="19" x2="12" y2="23"/>
                            <line x1="8" y1="23" x2="16" y2="23"/>
                        </svg>
                    </button>
                </div>
            </div>
            <button type="submit" class="send-button" id="sendBtn" title="Send">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <line x1="22" y1="2" x2="11" y2="13"/>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                </svg>
            </button>
        </div>
    </form>

    <!-- Voice Recording Overlay -->
    <div class="voice-recording-overlay" id="voiceRecordingOverlay">
        <div class="voice-recording-content">
            <div class="voice-recording-header">
                <div class="recording-timer" id="recordingTimer">0:00</div>
                <div class="lock-indicator" id="lockIndicator">
                    <div class="lock-icon" id="lockIcon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                            <path d="M7 11V7a5 5 0 0110 0v4"/>
                        </svg>
                    </div>
                    <span id="lockText">Slide up to lock</span>
                </div>
            </div>
            
            <div class="waveform-container" id="waveformContainer"></div>
            
            <div class="recording-controls" id="recordingControls">
                <button type="button" class="voice-control-btn cancel-btn" onclick="cancelVoiceRecording()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
                <button type="button" class="voice-control-btn pause-btn" id="pauseRecordBtn" onclick="togglePauseRecording()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                </button>
                <button type="button" class="voice-control-btn send-voice-btn" onclick="sendVoiceRecording()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <line x1="22" y1="2" x2="11" y2="13"/>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                    </svg>
                </button>
            </div>
            
            <div class="slide-instructions">
                <div class="slide-instruction">
                    <span>‚Üë Lock</span>
                </div>
                <div class="slide-instruction">
                    <span>‚Üê Cancel</span>
                </div>
                <div class="slide-instruction">
                    <span>Release to send</span>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // Sticker collection
    const stickers = [
        'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ',
        'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó', 'üòö', 'üòô',
        'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î',
        'üòê', 'üòë', 'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•', 'üòå', 'üòî',
        'üò™', 'ü§§', 'üò¥', 'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ', 'ü§ß', 'ü•µ',
        'ü•∂', 'üòµ', 'ü§Ø', 'ü§†', 'ü•≥', 'üòé', 'ü§ì', 'üßê', 'üòï', 'üòü',
        'üôÅ', '‚òπÔ∏è', 'üòÆ', 'üòØ', 'üò≤', 'üò≥', 'ü•∫', 'üò¶', 'üòß', 'üò®',
        'üò∞', 'üò•', 'üò¢', 'üò≠', 'üò±', 'üòñ', 'üò£', 'üòû', 'üòì', 'üò©',
        'üò´', 'ü•±', 'üò§', 'üò°', 'üò†', 'ü§¨', 'üëç', 'üëé', 'üëè', 'üôå',
        'üëã', 'ü§ù', 'üôè', 'üí™', 'üéâ', 'üéä', 'üéà', 'üéÅ', 'üèÜ', '‚öΩ',
        'üèÄ', 'üéØ', 'üéÆ', 'üé≤', 'üéµ', 'üé∂', 'üé§', 'üéß', 'üé∏', 'üéπ',
        '‚ù§Ô∏è', 'üíï', 'üíñ', 'üíó', 'üíô', 'üíö', 'üíõ', 'üß°', 'üíú', 'üñ§',
        'üíî', '‚ù£Ô∏è', 'üíû', 'üíù', 'üíò', 'üíå', 'üíã', 'üíØ', 'üí¢', 'üí•',
        'üî•', '‚ö°', 'üí´', '‚≠ê', 'üåü', '‚ú®', 'üí¶', 'üí®', '‚òÄÔ∏è', '‚õÖ',
        '‚òÅÔ∏è', 'üåßÔ∏è', '‚õàÔ∏è', 'üå©Ô∏è', 'üå®Ô∏è', '‚ùÑÔ∏è', '‚òÉÔ∏è', '‚õÑ', 'üåà', 'üåä'
    ];

    // Initialize sticker picker
    function initializeStickerPicker() {
        const stickerGrid = document.getElementById('stickerGrid');
        stickers.forEach(sticker => {
            const stickerBtn = document.createElement('button');
            stickerBtn.type = 'button';
            stickerBtn.className = 'sticker-item';
            stickerBtn.textContent = sticker;
            stickerBtn.onclick = () => sendSticker(sticker);
            stickerGrid.appendChild(stickerBtn);
        });
    }

    function toggleStickerPicker() {
        const picker = document.getElementById('stickerPicker');
        picker.classList.toggle('active');
    }

    function closeStickerPicker() {
        document.getElementById('stickerPicker').classList.remove('active');
    }

    function sendSticker(sticker) {
        messageInput.value = sticker;
        closeStickerPicker();
        toggleSendButton();
        submitMessage();
    }

    // Toggle send button visibility based on input
    function toggleSendButton() {
        const sendBtn = document.getElementById('sendBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        const attachBtn = document.getElementById('attachBtn');
        const cameraBtn = document.getElementById('cameraBtn');
        const hasText = messageInput.value.trim().length > 0;
        
        if (hasText) {
            sendBtn.classList.add('visible');
            voiceBtn.style.display = 'none';
            attachBtn.style.display = 'none';
            cameraBtn.style.display = 'none';
        } else {
            sendBtn.classList.remove('visible');
            voiceBtn.style.display = 'flex';
            attachBtn.style.display = 'flex';
            cameraBtn.style.display = 'flex';
        }
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', function() {
        console.log('[Init] DOM Content Loaded');
        
        initializeStickerPicker();
        toggleSendButton();
    });

    // Auto-scroll to bottom on page load
    const messagesContainer = document.getElementById('messages');
    
    // Aggressive scroll to bottom function
    function scrollToBottom(instant = false) {
        if (instant) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        } else {
            messagesContainer.scrollTo({
                top: messagesContainer.scrollHeight,
                behavior: 'instant'
            });
        }
    }
    
    // Execute multiple times to ensure it works
    scrollToBottom(true);
    requestAnimationFrame(() => scrollToBottom(true));
    setTimeout(() => scrollToBottom(true), 50);
    setTimeout(() => scrollToBottom(true), 200);
    setTimeout(() => scrollToBottom(true), 500);
    
    // Also execute after images/media load
    window.addEventListener('load', () => scrollToBottom(true));
    
    // Watch for any changes in the messages container
    const observer = new MutationObserver(() => scrollToBottom(true));
    observer.observe(messagesContainer, { childList: true, subtree: true });

    // Auto-resize textarea
    const messageInput = document.getElementById('messageInput');
    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
    });

    // Submit on Enter (but allow Shift+Enter for new line)
    messageInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            submitMessage();
        }
    });

    // Dismiss keyboard when clicking outside the input
    document.addEventListener('click', function(e) {
        const inputContainer = document.querySelector('.message-input-container');
        const stickerPicker = document.getElementById('stickerPicker');
        const input = document.getElementById('messageInput');
        
        // Close sticker picker if clicking outside
        if (stickerPicker.classList.contains('active') && !stickerPicker.contains(e.target) && !e.target.closest('.media-btn')) {
            closeStickerPicker();
        }
        
        // If click is outside the input container and input is focused
        if (!inputContainer.contains(e.target) && document.activeElement === input) {
            input.blur();
        }
    });

    // AJAX message submission
    const messageForm = document.getElementById('messageForm');
    const sendButton = messageForm.querySelector('.send-button');
    let isSubmitting = false;

    messageForm.addEventListener('submit', function(e) {
        e.preventDefault();
        submitMessage();
    });

    function submitMessage() {
        if (isSubmitting) return; // Prevent double submission
        
        const messageBody = messageInput.value.trim();
        
        // Check all file inputs for files
        const allFileInputs = messageForm.querySelectorAll('input[type="file"]');
        let hasFile = false;
        allFileInputs.forEach(input => {
            if (input.files && input.files.length > 0) {
                hasFile = true;
                console.log('[Submit] Found file:', input.files[0].name, 'in input:', input.name || input.id);
            }
        });
        
        console.log('[Submit] Message body:', messageBody, 'Has file:', hasFile);
        
        // Require either text or file
        if (!messageBody && !hasFile) {
            console.log('[Submit] Blocked: No message body and no file');
            return;
        }
        
        // Disable button and set submitting flag
        isSubmitting = true;
        sendButton.disabled = true;
        const originalContent = sendButton.innerHTML;
        sendButton.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" style="animation: spin 1s linear infinite;">
            <circle cx="12" cy="12" r="10"/>
        </svg>`;
        
        const formData = new FormData(messageForm);
        
        fetch(window.location.href, {
            method: 'POST',
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => {
            if (!response.ok) throw new Error('Network response was not ok');
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Add message to chat immediately for sender
                addMessageToChat(data.message);
                
                // Clear input and reply preview
                messageInput.value = '';
                messageInput.style.height = 'auto';
                cancelReply();
                toggleSendButton();
            }
        })
        .catch(error => {
            console.error('Error sending message:', error);
            alert('Failed to send message. Please try again.');
        })
        .finally(() => {
            // Re-enable button and clear file inputs
            isSubmitting = false;
            sendButton.disabled = false;
            sendButton.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <line x1="22" y1="2" x2="11" y2="13"/>
                <polygon points="22 2 15 22 11 13 2 9 22 2"/>
            </svg>`;
            
            // Clear all file inputs
            document.getElementById('imageInput').value = '';
            document.getElementById('videoInput').value = '';
            document.getElementById('voiceDuration').value = '';
            
            // Remove dynamic voice file input
            const voiceFileInput = document.getElementById('voiceFileInput');
            if (voiceFileInput) {
                voiceFileInput.remove();
                console.log('[Submit] Removed voice file input after submission');
            }
        });
    }

    // File input handlers
    document.getElementById('imageInput').addEventListener('change', function(e) {
        if (this.files.length > 0) {
            messageInput.placeholder = `üì∑ ${this.files[0].name}`;
            submitMessage();
        }
    });

    document.getElementById('videoInput').addEventListener('change', function(e) {
        if (this.files.length > 0) {
            messageInput.placeholder = `üé• ${this.files[0].name}`;
            submitMessage();
        }
    });

    // ============================================
    // Voice Recording - WhatsApp Style
    // ============================================
    let voiceRecorder = {
        mediaRecorder: null,
        audioChunks: [],
        stream: null,
        startTime: null,
        timerInterval: null,
        isLocked: false,
        isPaused: false,
        touchStartY: 0,
        touchStartX: 0,
        MAX_DURATION: 45, // seconds
        waveformBars: [],
        audioContext: null,
        analyser: null
    };

    function startVoiceRecording(event) {
        console.log('[Voice] Start recording triggered', event.type);
        event.preventDefault();
        event.stopPropagation();
        
        // Store touch start position
        if (event.type === 'touchstart') {
            voiceRecorder.touchStartY = event.touches[0].clientY;
            voiceRecorder.touchStartX = event.touches[0].clientX;
        } else {
            voiceRecorder.touchStartY = event.clientY;
            voiceRecorder.touchStartX = event.clientX;
        }
        
        console.log('[Voice] Starting recording initialization...');
        
        // Start recording
        initializeRecording();
        
        // Add event listeners for gestures
        document.addEventListener('mousemove', handleRecordingGesture);
        document.addEventListener('touchmove', handleRecordingGesture);
        document.addEventListener('mouseup', handleRecordingRelease);
        document.addEventListener('touchend', handleRecordingRelease);
    }

    async function initializeRecording() {
        try {
            console.log('[Voice] Requesting microphone access...');
            
            // Request microphone access
            voiceRecorder.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log('[Voice] Microphone access granted');
            
            // Initialize MediaRecorder
            voiceRecorder.mediaRecorder = new MediaRecorder(voiceRecorder.stream);
            voiceRecorder.audioChunks = [];
            voiceRecorder.startTime = Date.now();
            voiceRecorder.isLocked = false;
            voiceRecorder.isPaused = false;
            console.log('[Voice] MediaRecorder initialized');
            
            // Setup audio analysis for waveform
            setupAudioAnalysis();
            
            // Show overlay
            document.getElementById('voiceRecordingOverlay').classList.add('active');
            document.getElementById('voiceBtn').classList.add('recording');
            console.log('[Voice] Overlay shown');
            
            // Initialize waveform
            initializeWaveform();
            
            // Start timer
            startRecordingTimer();
            
            // Start recording
            voiceRecorder.mediaRecorder.ondataavailable = (event) => {
                voiceRecorder.audioChunks.push(event.data);
            };
            
            voiceRecorder.mediaRecorder.start();
            console.log('[Voice] Recording started successfully');
            
            // Haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
        } catch (error) {
            console.error('[Voice] Error accessing microphone:', error);
            alert('Could not access microphone. Please check permissions.');
        }
    }

    function setupAudioAnalysis() {
        voiceRecorder.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        voiceRecorder.analyser = voiceRecorder.audioContext.createAnalyser();
        const source = voiceRecorder.audioContext.createMediaStreamSource(voiceRecorder.stream);
        source.connect(voiceRecorder.analyser);
        voiceRecorder.analyser.fftSize = 64;
        
        animateWaveform();
    }

    function initializeWaveform() {
        const container = document.getElementById('waveformContainer');
        container.innerHTML = '';
        voiceRecorder.waveformBars = [];
        
        for (let i = 0; i < 30; i++) {
            const bar = document.createElement('div');
            bar.className = 'waveform-bar';
            bar.style.animationDelay = `${i * 0.05}s`;
            container.appendChild(bar);
            voiceRecorder.waveformBars.push(bar);
        }
    }

    function animateWaveform() {
        if (!voiceRecorder.analyser || voiceRecorder.isPaused) return;
        
        const dataArray = new Uint8Array(voiceRecorder.analyser.frequencyBinCount);
        voiceRecorder.analyser.getByteFrequencyData(dataArray);
        
        voiceRecorder.waveformBars.forEach((bar, index) => {
            const dataIndex = Math.floor(index * dataArray.length / voiceRecorder.waveformBars.length);
            const value = dataArray[dataIndex];
            const height = Math.max(10, (value / 255) * 50);
            bar.style.height = `${height}px`;
        });
        
        if (voiceRecorder.mediaRecorder && voiceRecorder.mediaRecorder.state === 'recording') {
            requestAnimationFrame(animateWaveform);
        }
    }

    function startRecordingTimer() {
        updateTimer();
        voiceRecorder.timerInterval = setInterval(() => {
            updateTimer();
            
            // Check if max duration reached
            const elapsed = (Date.now() - voiceRecorder.startTime) / 1000;
            if (elapsed >= voiceRecorder.MAX_DURATION) {
                sendVoiceRecording();
            } else if (elapsed >= voiceRecorder.MAX_DURATION - 5) {
                // Warning at 5 seconds remaining
                document.getElementById('recordingTimer').classList.add('warning');
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
            }
        }, 100);
    }

    function updateTimer() {
        const elapsed = (Date.now() - voiceRecorder.startTime) / 1000;
        const minutes = Math.floor(elapsed / 60);
        const seconds = Math.floor(elapsed % 60);
        document.getElementById('recordingTimer').textContent = 
            `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function handleRecordingGesture(event) {
        if (!voiceRecorder.mediaRecorder || voiceRecorder.isLocked) return;
        
        let currentY, currentX;
        if (event.type === 'touchmove') {
            currentY = event.touches[0].clientY;
            currentX = event.touches[0].clientX;
        } else {
            currentY = event.clientY;
            currentX = event.clientX;
        }
        
        const deltaY = voiceRecorder.touchStartY - currentY;
        const deltaX = voiceRecorder.touchStartX - currentX;
        
        // Slide up to lock (>100px)
        if (deltaY > 100) {
            lockRecording();
        }
        
        // Slide left to cancel (>150px)
        if (deltaX > 150) {
            cancelVoiceRecording();
        }
    }

    function lockRecording() {
        voiceRecorder.isLocked = true;
        document.getElementById('lockIcon').classList.add('locked');
        document.getElementById('lockText').textContent = 'Recording locked';
        
        // Remove gesture listeners
        document.removeEventListener('mousemove', handleRecordingGesture);
        document.removeEventListener('touchmove', handleRecordingGesture);
        
        // Haptic feedback
        if (navigator.vibrate) {
            navigator.vibrate([50, 100, 50]);
        }
    }

    function handleRecordingRelease(event) {
        if (!voiceRecorder.mediaRecorder) return;
        
        // Remove listeners
        document.removeEventListener('mousemove', handleRecordingGesture);
        document.removeEventListener('touchmove', handleRecordingGesture);
        document.removeEventListener('mouseup', handleRecordingRelease);
        document.removeEventListener('touchend', handleRecordingRelease);
        
        // If locked, do nothing (user must use buttons)
        if (voiceRecorder.isLocked) return;
        
        // Otherwise, send immediately
        sendVoiceRecording();
    }

    function togglePauseRecording() {
        if (!voiceRecorder.mediaRecorder) return;
        
        const pauseBtn = document.getElementById('pauseRecordBtn');
        
        if (voiceRecorder.isPaused) {
            // Resume
            voiceRecorder.isPaused = false;
            voiceRecorder.mediaRecorder.resume();
            pauseBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <rect x="6" y="4" width="4" height="16"/>
                <rect x="14" y="4" width="4" height="16"/>
            </svg>`;
            animateWaveform();
        } else {
            // Pause
            voiceRecorder.isPaused = true;
            voiceRecorder.mediaRecorder.pause();
            pauseBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>`;
        }
        
        if (navigator.vibrate) {
            navigator.vibrate(30);
        }
    }

    async function sendVoiceRecording() {
        if (!voiceRecorder.mediaRecorder) return;
        
        // Stop recording
        voiceRecorder.mediaRecorder.stop();
        
        // Stop timer
        clearInterval(voiceRecorder.timerInterval);
        
        // Stop audio analysis
        if (voiceRecorder.audioContext) {
            voiceRecorder.audioContext.close();
        }
        
        // Wait for data
        voiceRecorder.mediaRecorder.onstop = async () => {
            console.log('[Voice] Recording stopped, processing audio...');
            const audioBlob = new Blob(voiceRecorder.audioChunks, { type: 'audio/webm' });
            const duration = Math.floor((Date.now() - voiceRecorder.startTime) / 1000);
            
            console.log('[Voice] Audio blob size:', audioBlob.size, 'bytes, duration:', duration, 'seconds');
            
            // Create file from blob
            const file = new File([audioBlob], `voice_${Date.now()}.webm`, { type: 'audio/webm' });
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            
            console.log('[Voice] Created file:', file.name, 'size:', file.size);
            
            // Remove old dynamic file inputs (not the original image/video inputs)
            messageForm.querySelectorAll('input[type="file"]').forEach(input => {
                if (input.id !== 'imageInput' && input.id !== 'videoInput' && input.id !== 'fileInput') {
                    console.log('[Voice] Removing old file input:', input.name || input.id);
                    input.remove();
                }
            });
            
            // Create and add new file input for voice
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.name = 'file';
            fileInput.files = dataTransfer.files;
            fileInput.style.display = 'none';
            fileInput.id = 'voiceFileInput';
            messageForm.appendChild(fileInput);
            
            console.log('[Voice] Added voice file input with', fileInput.files.length, 'files');
            
            // Set duration
            document.getElementById('voiceDuration').value = duration;
            console.log('[Voice] Set voice duration:', duration);
            
            // Stop all tracks
            voiceRecorder.stream.getTracks().forEach(track => track.stop());
            
            // Clean up UI
            closeVoiceRecording();
            
            // Submit after a small delay to ensure file input is properly attached
            console.log('[Voice] Submitting voice message...');
            setTimeout(() => {
                submitMessage();
            }, 100);
        };
        
        // Haptic feedback
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
    }

    function cancelVoiceRecording() {
        if (!voiceRecorder.mediaRecorder) return;
        
        // Stop recording
        voiceRecorder.mediaRecorder.stop();
        
        // Stop timer
        clearInterval(voiceRecorder.timerInterval);
        
        // Stop audio analysis
        if (voiceRecorder.audioContext) {
            voiceRecorder.audioContext.close();
        }
        
        // Stop all tracks
        if (voiceRecorder.stream) {
            voiceRecorder.stream.getTracks().forEach(track => track.stop());
        }
        
        // Clean up
        closeVoiceRecording();
        
        // Haptic feedback
        if (navigator.vibrate) {
            navigator.vibrate([50, 50, 50]);
        }
    }

    function closeVoiceRecording() {
        document.getElementById('voiceRecordingOverlay').classList.remove('active');
        document.getElementById('voiceBtn').classList.remove('recording');
        document.getElementById('recordingTimer').classList.remove('warning');
        document.getElementById('lockIcon').classList.remove('locked');
        document.getElementById('lockText').textContent = 'Slide up to lock';
        
        // Reset recorder state
        voiceRecorder.mediaRecorder = null;
        voiceRecorder.audioChunks = [];
        voiceRecorder.stream = null;
        voiceRecorder.isLocked = false;
        voiceRecorder.isPaused = false;
        
        // Remove event listeners
        document.removeEventListener('mousemove', handleRecordingGesture);
        document.removeEventListener('touchmove', handleRecordingGesture);
        document.removeEventListener('mouseup', handleRecordingRelease);
        document.removeEventListener('touchend', handleRecordingRelease);
    }

    // ============================================
    // Voice Message Playback - Enhanced
    // ============================================
    const voicePlaybackStates = new Map();

    function playVoice(button, url, messageId) {
        const voiceMessage = button.closest('.voice-message');
        const audio = voiceMessage.querySelector('audio');
        const speedControl = voiceMessage.querySelector('.voice-speed');
        const durationDisplay = voiceMessage.querySelector('.voice-duration');
        const waveformBars = voiceMessage.querySelectorAll('.voice-waveform-bar');
        
        // Initialize state if not exists
        if (!voicePlaybackStates.has(messageId)) {
            voicePlaybackStates.set(messageId, {
                playbackRate: 1.0,
                lastPosition: 0
            });
        }
        
        const state = voicePlaybackStates.get(messageId);
        
        // Set playback rate
        audio.playbackRate = state.playbackRate;
        
        // Resume from last position if available
        if (state.lastPosition > 0 && audio.currentTime === 0) {
            audio.currentTime = state.lastPosition;
        }
        
        if (audio.paused) {
            // Play
            audio.play();
            button.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <rect x="6" y="4" width="4" height="16"/>
                <rect x="14" y="4" width="4" height="16"/>
            </svg>`;
            
            // Update progress
            audio.ontimeupdate = () => {
                updateVoiceProgress(audio, waveformBars, durationDisplay);
                state.lastPosition = audio.currentTime;
            };
            
            audio.onended = () => {
                button.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor">
                    <polygon points="5 3 19 12 5 21 5 3"/>
                </svg>`;
                state.lastPosition = 0;
                resetVoiceProgress(waveformBars, durationDisplay, audio.duration);
            };
            
        } else {
            // Pause
            audio.pause();
            button.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor">
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>`;
        }
        
        // Haptic feedback
        if (navigator.vibrate) {
            navigator.vibrate(30);
        }
    }

    function updateVoiceProgress(audio, waveformBars, durationDisplay) {
        const progress = audio.currentTime / audio.duration;
        const playedCount = Math.floor(progress * waveformBars.length);
        
        waveformBars.forEach((bar, index) => {
            if (index < playedCount) {
                bar.classList.add('played');
            } else {
                bar.classList.remove('played');
            }
        });
        
        // Update duration display
        const remaining = audio.duration - audio.currentTime;
        const minutes = Math.floor(remaining / 60);
        const seconds = Math.floor(remaining % 60);
        durationDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function resetVoiceProgress(waveformBars, durationDisplay, totalDuration) {
        waveformBars.forEach(bar => bar.classList.remove('played'));
        const minutes = Math.floor(totalDuration / 60);
        const seconds = Math.floor(totalDuration % 60);
        durationDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function cyclePlaybackSpeed(messageId, speedControl) {
        const state = voicePlaybackStates.get(messageId) || { playbackRate: 1.0, lastPosition: 0 };
        
        // Cycle through speeds: 1x -> 1.5x -> 2x -> 1x
        if (state.playbackRate === 1.0) {
            state.playbackRate = 1.5;
        } else if (state.playbackRate === 1.5) {
            state.playbackRate = 2.0;
        } else {
            state.playbackRate = 1.0;
        }
        
        voicePlaybackStates.set(messageId, state);
        speedControl.textContent = `${state.playbackRate}x`;
        
        // Update audio playback rate if playing
        const voiceMessage = speedControl.closest('.voice-message');
        const audio = voiceMessage.querySelector('audio');
        if (audio) {
            audio.playbackRate = state.playbackRate;
        }
        
        // Haptic feedback
        if (navigator.vibrate) {
            navigator.vibrate(30);
        }
    }

    // Reply feature - Swipe to reply
    let touchStartX = 0;
    let touchStartY = 0;
    let currentSwipeElement = null;

    function setReply(messageId, messageBody, senderUsername) {
        document.getElementById('replyToId').value = messageId;
        document.getElementById('replyToUser').textContent = senderUsername;
        document.getElementById('replyPreviewBody').textContent = messageBody;
        document.getElementById('replyPreview').classList.add('active');
        document.getElementById('messageInput').focus();
    }

    function cancelReply() {
        document.getElementById('replyToId').value = '';
        document.getElementById('replyPreview').classList.remove('active');
    }

    // Add swipe gesture to all messages
    document.querySelectorAll('.message').forEach(message => {
        const wrapper = message.querySelector('.message-bubble-wrapper');
        const indicator = message.querySelector('.reply-indicator');
        let isHorizontalSwipe = false;
        
        message.addEventListener('touchstart', function(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            currentSwipeElement = wrapper;
            isHorizontalSwipe = false;
        }, { passive: true });

        message.addEventListener('touchmove', function(e) {
            if (!currentSwipeElement) return;
            
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const diffX = touchX - touchStartX;
            const diffY = touchY - touchStartY;
            
            // Determine if it's a horizontal swipe on first significant movement
            if (!isHorizontalSwipe && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
                isHorizontalSwipe = Math.abs(diffX) > Math.abs(diffY);
            }
            
            // Only respond to horizontal swipes (not vertical scrolls)
            if (isHorizontalSwipe && Math.abs(diffX) > 20) {
                e.preventDefault();
                e.stopPropagation();
                
                // Limit swipe distance
                const maxSwipe = 80;
                const swipeDistance = Math.min(Math.abs(diffX), maxSwipe);
                const direction = message.classList.contains('sent') ? -1 : 1;
                
                wrapper.style.transform = `translateX(${direction * swipeDistance}px)`;
                indicator.style.opacity = swipeDistance / maxSwipe;
            }
        }, { passive: false });

        message.addEventListener('touchend', function(e) {
            if (!currentSwipeElement) return;
            
            const touchX = e.changedTouches[0].clientX;
            const diffX = Math.abs(touchX - touchStartX);
            
            // If swiped more than 50px, trigger reply
            if (diffX > 50) {
                const messageId = message.dataset.messageId;
                const messageBody = message.dataset.messageBody;
                const sender = message.dataset.sender;
                setReply(messageId, messageBody, sender);
            }
            
            // Reset position
            wrapper.style.transform = '';
            indicator.style.opacity = '0';
            currentSwipeElement = null;
        });

        // Also add click on reply indicator for desktop
        indicator.addEventListener('click', function() {
            const messageId = message.dataset.messageId;
            const messageBody = message.dataset.messageBody;
            const sender = message.dataset.sender;
            setReply(messageId, messageBody, sender);
        });

        // Long press for desktop/tablet
        let longPressTimer;
        message.addEventListener('mousedown', function() {
            longPressTimer = setTimeout(() => {
                const messageId = message.dataset.messageId;
                const messageBody = message.dataset.messageBody;
                const sender = message.dataset.sender;
                setReply(messageId, messageBody, sender);
            }, 500);
        });

        message.addEventListener('mouseup', function() {
            clearTimeout(longPressTimer);
        });

        message.addEventListener('mouseleave', function() {
            clearTimeout(longPressTimer);
        });
    });

    // WebSocket for real-time messages
    const conversationId = {{ conversation.id }};
    const currentUserId = {{ request.user.id }};
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/chat/${conversationId}/`;
    
    let chatSocket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;

    function connectChatWebSocket() {
        console.log('[Chat] Connecting to:', wsUrl);
        chatSocket = new WebSocket(wsUrl);

        chatSocket.onopen = function(e) {
            console.log('[Chat] ‚úÖ Connected to conversation');
            reconnectAttempts = 0;
        };

        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            console.log('[Chat] üì® Received:', data);
            
            if (data.type === 'new_message') {
                // Add message for other user (sender already added it via AJAX response)
                if (data.message.sender_id !== currentUserId) {
                    addMessageToChat(data.message);
                }
            }
        };

        chatSocket.onerror = function(e) {
            console.error('[Chat] ‚ùå WebSocket error:', e);
        };

        chatSocket.onclose = function(e) {
            console.log('[Chat] üîå Disconnected. Code:', e.code);
            
            // Try to reconnect
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 10000);
                console.log(`[Chat] üîÑ Reconnecting in ${delay}ms... (Attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
                setTimeout(connectChatWebSocket, delay);
            } else {
                console.log('[Chat] ‚ö†Ô∏è Max reconnection attempts reached');
            }
        };
    }

    function addMessageToChat(message) {
        const messagesContainer = document.getElementById('messages');
        const isReceived = message.sender_id !== currentUserId;
        
        // Create message element
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isReceived ? 'received' : 'sent'}`;
        messageDiv.dataset.messageId = message.id;
        messageDiv.dataset.messageBody = message.body;
        messageDiv.dataset.sender = message.sender_username;
        
        let avatarHtml = '';
        if (isReceived) {
            if (message.sender_avatar) {
                avatarHtml = `<img src="${message.sender_avatar}" alt="${message.sender_username}" class="message-avatar">`;
            } else {
                avatarHtml = '<div class="message-avatar" style="background: linear-gradient(135deg, var(--color-main-light), var(--color-main));"></div>';
            }
        }
        
        let senderNameHtml = '';
        if (isReceived) {
            senderNameHtml = `<span class="sender-name">${message.sender_username}</span>`;
        }
        
        let replyHtml = '';
        if (message.reply_to) {
            let replyContent = '';
            if (message.reply_to.file_type === 'image') {
                replyContent = 'üì∑ Photo';
            } else if (message.reply_to.file_type === 'video') {
                replyContent = 'üé• Video';
            } else if (message.reply_to.file_type === 'voice') {
                replyContent = 'üé§ Voice message';
            } else {
                replyContent = truncateText(message.reply_to.body || '', 10);
            }
            replyHtml = `
                <div class="replied-message">
                    <strong>${message.reply_to.sender_username}:</strong> ${replyContent}
                </div>
            `;
        }
        
        // Build media content
        let mediaHtml = '';
        if (message.file_type === 'image' && message.file_url) {
            mediaHtml = `<div class="message-media"><img src="${message.file_url}" alt="Image" loading="lazy"></div>`;
        } else if (message.file_type === 'video' && message.file_url) {
            mediaHtml = `<div class="message-media"><video controls><source src="${message.file_url}" type="video/mp4"></video></div>`;
        } else if (message.file_type === 'voice' && message.file_url) {
            const duration = message.voice_duration || 0;
            const waveformBars = Array(25).fill(0).map(() => '<div class="voice-waveform-bar"></div>').join('');
            mediaHtml = `
                <div class="voice-message" data-message-id="${message.id}">
                    <button class="voice-play-btn" onclick="playVoice(this, '${message.file_url}', ${message.id})">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="5 3 19 12 5 21 5 3"/>
                        </svg>
                    </button>
                    <div class="voice-content">
                        <div class="voice-progress-container">
                            <div class="voice-waveform">${waveformBars}</div>
                        </div>
                        <div class="voice-info">
                            <span class="voice-duration">${duration}s</span>
                            <span class="voice-speed" onclick="cyclePlaybackSpeed(${message.id}, this)">1x</span>
                        </div>
                    </div>
                    <audio style="display:none;" src="${message.file_url}"></audio>
                </div>
            `;
        }
        
        // Extract time from created timestamp
        const timeOnly = message.created.split(',')[1]?.trim() || message.created;
        
        messageDiv.innerHTML = `
            ${avatarHtml}
            <div class="message-content">
                ${senderNameHtml}
                <div class="message-bubble-wrapper">
                    <div class="message-bubble ${message.reply_to ? 'message-with-reply' : ''}">
                        ${replyHtml}
                        ${mediaHtml}
                        ${message.body || ''}
                        <span class="message-time">${timeOnly}</span>
                    </div>
                    <span class="reply-indicator">‚Ü©Ô∏è</span>
                </div>
            </div>
        `;
        
        // Add fade-in animation
        messageDiv.style.opacity = '0';
        messageDiv.style.transform = 'translateY(20px)';
        
        messagesContainer.appendChild(messageDiv);
        
        // Trigger animation
        requestAnimationFrame(() => {
            messageDiv.style.transition = 'all 0.3s ease';
            messageDiv.style.opacity = '1';
            messageDiv.style.transform = 'translateY(0)';
        });
        
        // Scroll to bottom
        messagesContainer.scrollTo({
            top: messagesContainer.scrollHeight,
            behavior: 'smooth'
        });
        
        // Setup swipe gesture for new message
        setupSwipeGesture(messageDiv);
    }

    function truncateText(text, words) {
        const wordArray = text.split(' ');
        if (wordArray.length > words) {
            return wordArray.slice(0, words).join(' ') + '...';
        }
        return text;
    }

    function setupSwipeGesture(message) {
        const wrapper = message.querySelector('.message-bubble-wrapper');
        const indicator = message.querySelector('.reply-indicator');
        let localTouchStartX = 0;
        let localTouchStartY = 0;
        let localCurrentSwipeElement = null;
        let localIsHorizontalSwipe = false;
        
        message.addEventListener('touchstart', function(e) {
            localTouchStartX = e.touches[0].clientX;
            localTouchStartY = e.touches[0].clientY;
            localCurrentSwipeElement = wrapper;
            localIsHorizontalSwipe = false;
        }, { passive: true });

        message.addEventListener('touchmove', function(e) {
            if (!localCurrentSwipeElement) return;
            
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const diffX = touchX - localTouchStartX;
            const diffY = touchY - localTouchStartY;
            
            // Determine if it's a horizontal swipe on first significant movement
            if (!localIsHorizontalSwipe && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
                localIsHorizontalSwipe = Math.abs(diffX) > Math.abs(diffY);
            }
            
            if (localIsHorizontalSwipe && Math.abs(diffX) > 20) {
                e.preventDefault();
                e.stopPropagation();
                const maxSwipe = 80;
                const swipeDistance = Math.min(Math.abs(diffX), maxSwipe);
                const direction = message.classList.contains('sent') ? -1 : 1;
                
                wrapper.style.transform = `translateX(${direction * swipeDistance}px)`;
                indicator.style.opacity = swipeDistance / maxSwipe;
            }
        }, { passive: false });

        message.addEventListener('touchend', function(e) {
            if (!localCurrentSwipeElement) return;
            
            const touchX = e.changedTouches[0].clientX;
            const diffX = Math.abs(touchX - localTouchStartX);
            
            if (diffX > 50) {
                const messageId = message.dataset.messageId;
                const messageBody = message.dataset.messageBody;
                const sender = message.dataset.sender;
                setReply(messageId, messageBody, sender);
            }
            
            wrapper.style.transform = '';
            indicator.style.opacity = '0';
            localCurrentSwipeElement = null;
        });
    }

    // Connect to WebSocket
    connectChatWebSocket();

</script>

{% endblock %}
